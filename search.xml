<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>typescript 笔记</title>
      <link href="/2019/11/05/typescript/"/>
      <url>/2019/11/05/typescript/</url>
      
        <content type="html"><![CDATA[<h1 id="TypeScript-简介"><a href="#TypeScript-简介" class="headerlink" title="TypeScript 简介"></a>TypeScript 简介</h1><p>TypeScript 并不是一个完全新的语言, 它是 JavaScript 的超集，为 JavaScript 的生态增加了类型机制，并最终将代码编译为纯粹的 JavaScript 代码。</p><p>TypeScript 由 Microsoft开发和维护的一种开源编程语言。 它支持 JavaScript 的所有语法和语义，同时在 JavaScript 的基础上添加了可选的静态类型和基于类的面向对象编程。因而TypeScript更适合开发大型应用程序。</p><a id="more"></a><p>TypeScript 与JavaScript两者的特性对比，主要表现为以下几点：</p><p>1、TypeScript是一个应用程序级的JavaScript开发语言。（这也表示TypeScript比较牛逼，可以开发大型应用，或者说更适合开发大型应用）<br>2、TypeScript是JavaScript的超集，可以编译成纯JavaScript。这个和我们CSS离的Less或者Sass是很像的，我们用更好的代码编写方式来进行编写，最后还是有好生成原生的JavaScript语言。<br>3、TypeScript跨浏览器、跨操作系统、跨主机、且开源。由于最后他编译成了JavaScript所以只要能运行JS的地方，都可以运行我们写的程序，设置在node.js里。<br>TypeScript始于JavaScript，终于JavaScript。遵循JavaScript的语法和语义，所以对于我们前端从业者来说，学习前来得心应手，并没有太大的难度。<br>4、TypeScript可以重用JavaScript代码，调用流行的JavaScript库。<br>5、TypeScript提供了类、模块和接口，更易于构建组件和维护。</p><p>目前流行的框架中使用typesript有angular2和马上要发布vue3.0。</p><p>注：Node.js之父瑞安达尔（Ryan Dahl）发布了新的开源项目 deno，从官方介绍来看，你可以认为它是下一代 Node，使用 Go 语言代替 C++ 重新编写跨平台底层内核驱动，上层仍然使用 V8 引擎，最终提供一个安全的 TypeScript 运行环境。另Dahl在公开场合曾表示Node.js已经无力回天，Deno将是他的代替品。</p><h1 id="安装TypeScript开发环境"><a href="#安装TypeScript开发环境" class="headerlink" title="安装TypeScript开发环境"></a>安装TypeScript开发环境</h1><p>1、安装node.js开发环境</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">node -v</span><br><span class="line">npm -v</span><br></pre></td></tr></table></figure><p>2、安装TypeScript安装包</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">npm install typescirpt -g</span><br><span class="line">tsc --version</span><br></pre></td></tr></table></figure><p>3、编写一个HelloWorld程序</p><p>1.初始化项目:新建一个编程文件夹以后，可以用<code>npm init -y</code>来初始化项目，生成package.json文件<br>2.创建tsconfig.json文件，在终端中输入<code>tsc --init</code>,它是一个TypeScript项目的配置文件，可以通过读取它来设置TypeScript编译器的编译参数<br>3.安装@types/node,使用<code>npm install @types/node --dev-save</code>进行安装。这个主要是解决模块的声明文件问题<br>4.编写HelloWorld.ts文件，然后进行保存</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">var a:string = &quot;HelloWorld&quot;</span><br><span class="line">consloe.log(a)</span><br></pre></td></tr></table></figure><p>5.在Vscode的任务菜单下，打开运行生成任务，然后选择<code>tsc：构建-tsconfig.json</code>，这时候就会生成一个helloWorld.js文件<br>6.在终端中输入<code>node helloWorld.js</code>就可以看到结果了</p><h1 id="TypeScript-数据类型"><a href="#TypeScript-数据类型" class="headerlink" title="TypeScript 数据类型"></a>TypeScript 数据类型</h1><p>JavaScript的数据类型分为两种，原始数据类型和引用数据类型。<br>原始数据类型包括：布尔值Boolean、数值Number、字符串String、null、undefined 以及 ES6 中的新类型 Symbol。</p><p>TypeScript中的数据类型有：</p><p>Number:数值类型（可以是整数也可以是小数）<br>string : 字符串类型<br>Boolean: 布尔类型<br>enum：枚举类型<br>any : 任意类型<br>void：空类型<br>Array : 数组类型<br>Tuple : 元祖类型<br>Null<br>Undefined </p><h3 id="number-类型"><a href="#number-类型" class="headerlink" title="number 类型"></a>number 类型</h3><p>使用number来定义数值类型</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">let decLiteral: number = 6;</span><br><span class="line">let hexLiteral: number = 0xf00d;</span><br><span class="line">// ES6 中的二进制表示法</span><br><span class="line">let binaryLiteral: number = 0b1010;</span><br><span class="line">// ES6 中的八进制表示法</span><br><span class="line">let octalLiteral: number = 0o744;</span><br><span class="line">let notANumber: number = NaN;</span><br><span class="line">let infinityNumber: number = Infinity;</span><br></pre></td></tr></table></figure><h3 id="string-类型"><a href="#string-类型" class="headerlink" title="string 类型"></a>string 类型</h3><p>TypeScript中存在两种类型的字符串：基本类型字符串和引用类型字符串。<br>基本类型字符串：由单引号或者双引号括起来的一串字符串。<br>引用类型字符串：用new 实例化的 String类型。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">let tsc:string = &apos;typescript&apos;</span><br><span class="line">let tsca:String = new String(&quot;typescript.com&quot;)</span><br><span class="line">console.log(tsc)</span><br><span class="line">console.log(tsca)</span><br><span class="line"></span><br><span class="line">typescript</span><br><span class="line">[String: &apos;typescript.com&apos;]</span><br></pre></td></tr></table></figure><h3 id="enum枚举类型"><a href="#enum枚举类型" class="headerlink" title="enum枚举类型"></a>enum枚举类型</h3><p>假如变量时几个固定数据时，比较适合用枚举类型。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">enum season&#123;spring,summer,autumn,winter&#125;</span><br><span class="line">console.log(season.autumn)</span><br><span class="line">//返回了2，这是索引index，跟数组很像</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">enum season = &#123;</span><br><span class="line">  spring: &apos;春天&apos;,</span><br><span class="line">  summer: &apos;夏天&apos;,</span><br><span class="line">  autumn: &apos;秋天&apos;,</span><br><span class="line">  winter: &apos;冬天&apos;</span><br><span class="line">&#125;</span><br><span class="line">console.log(season.autumn)</span><br><span class="line">//返回秋天</span><br></pre></td></tr></table></figure><h3 id="any类型"><a href="#any类型" class="headerlink" title="any类型"></a>any类型</h3><p>任意值（Any）用来表示允许赋值为任意类型。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">let myFavoriteNumber: any = &apos;seven&apos;;</span><br><span class="line">myFavoriteNumber = 7;</span><br></pre></td></tr></table></figure><h3 id="void类型"><a href="#void类型" class="headerlink" title="void类型"></a>void类型</h3><p>空类型，一般用于没有任何返回值的函数</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">function name():void &#123;</span><br><span class="line">  console.log(&apos;my name is X&apos;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="array类型"><a href="#array类型" class="headerlink" title="array类型"></a>array类型</h3><p>初始化数组两种方法<br>1.字面量赋值法</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">let arr1:number[] = [1,2,3,4,5] //声明一个数值类型的数组</span><br><span class="line">let arr2:Array&lt;string&gt; = [&apos;a&apos;,&apos;b&apos;,&apos;c&apos;] //声明一个字符串类型的数组</span><br><span class="line">let arr3:Array&lt;boolean&gt; = [true,false,false] //声明一个布尔类型的数组</span><br></pre></td></tr></table></figure><p>2.构造函数赋值法</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">let arr1:number[] = new Array(1,2,3,4,5) //声明一个数值类型的数组</span><br><span class="line">let arr2:Array&lt;string&gt; = new Array(&apos;a&apos;,&apos;b&apos;,&apos;c&apos;) //声明一个字符串类型的数组</span><br><span class="line">let arr3:Array&lt;boolean&gt; = new Array(true,false,false) //声明一个布尔类型的数组</span><br></pre></td></tr></table></figure><h3 id="tuple元祖类型"><a href="#tuple元祖类型" class="headerlink" title="tuple元祖类型"></a>tuple元祖类型</h3><p>元祖是一种特殊的数组，元祖类型允许表示一个已知元素数量和类型的数组，各元素的类型不必相同。比如，你可以定义一对值分别为string和number类型的元祖。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">//声明一个元祖类型</span><br><span class="line">let x : [string,number]</span><br><span class="line">//正确的初始化</span><br><span class="line">x = [&apos;hello&apos;,10]</span><br><span class="line">//错误的初始化方法</span><br><span class="line">x = [10,&apos;hello&apos;]</span><br></pre></td></tr></table></figure><h1 id="TypeScript中的函数"><a href="#TypeScript中的函数" class="headerlink" title="TypeScript中的函数"></a>TypeScript中的函数</h1><p>函数基本是程序里第一等公民。</p><p>声明函数需要注意的是：<br>1、声明（定义）函数必须加 function 关键字<br>2、函数名与变量名一样，命名规则按照标识符规则<br>3、函数参数可有可无，多个参数之间用逗号隔开<br>4、每个参数参数由名字与类型组成，之间用分号隔开<br>5、函数的返回值可有可无，没有时，返回类型为 void<br>6、大括号中是函数体。</p><p>函数定义的三种方式：</p><p>1、函数声明法<br>函数声明法创建函数是最常用的函数定义法。使用function关键字和函数名去定义一个函数。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">function add(n1:number,n2:number):number &#123;</span><br><span class="line">  return n1+n2</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>2、函数表达式法<br>函数表达式法是将一个函数赋值给一个变量，这个变量名就是函数名。通过变量名就可以调用函数了。这种方式定义的函数，必须在定义之后，调用函数。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">var add = function(n1:number,n2:number):number &#123;</span><br><span class="line">  return n1+n2</span><br><span class="line">&#125;</span><br><span class="line">console.log(add(1,4))</span><br></pre></td></tr></table></figure><p>3、箭头函数<br>箭头函数是 ES6 中新增的函数定义的新方式，我们的 TypeScript 语言是完全支持 ES6 语法的。箭头函数定义的函数一般都用于回调函数中。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">var add = function(n1:number,n2:number):number =&gt;&#123;</span><br><span class="line">  return n1+n2</span><br><span class="line">&#125;</span><br><span class="line">console.log(add(1,4))</span><br></pre></td></tr></table></figure><h1 id="面向对象编程"><a href="#面向对象编程" class="headerlink" title="面向对象编程"></a>面向对象编程</h1><p>TypeScript就是一个基于类的面向对象编程语言。</p><h3 id="1、类的声明和使用"><a href="#1、类的声明和使用" class="headerlink" title="1、类的声明和使用"></a>1、类的声明和使用</h3><p>类是对象具体事务的一个抽象，对象是类的具体表现。<br>类的定义：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">class Person&#123;</span><br><span class="line">    name:string;</span><br><span class="line">    age:number;</span><br><span class="line">    constructor(name:string,age:number)&#123;</span><br><span class="line">        this.name = name</span><br><span class="line">        this.age = age </span><br><span class="line">    &#125;</span><br><span class="line">    say()&#123;</span><br><span class="line">        console.log(&apos;hello&apos;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">let p:Person = new Person(&apos;lihua&apos;,18)</span><br><span class="line">console.log(p)</span><br><span class="line">p.say()</span><br></pre></td></tr></table></figure><p>我们先用class关键字声明了一个类，并在里边声明了name和age属性。constructor为构造函数。构造函数的主要作用是给类中封装的属性进行赋值。</p><p>使用和定义类其实很简单，关键是理解类的思想。要有抽象逻辑的能力，这样才能复用和增强维护性。</p><h3 id="2、修饰符"><a href="#2、修饰符" class="headerlink" title="2、修饰符"></a>2、修饰符</h3><p>TypeScript语言和Java还有C#很像（因为我只会这两个面向对象的语言），类中属性的访问可以用访问修饰符来进行限制。访问修饰符分为：public、protected、private。</p><p>public:公有修饰符，可以在类内或者类外使用public修饰的属性或者行为，默认修饰符。<br>protected:受保护的修饰符，可以本类和子类中使用protected修饰的属性和行为。<br>private : 私有修饰符，只可以在类内使用private修饰的属性和行为。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">class people&#123;</span><br><span class="line">    public sex:string</span><br><span class="line">    protected name:string</span><br><span class="line">    private age:number</span><br><span class="line">    public constructor(sex:string,name:string,age:number)&#123;</span><br><span class="line">        this.sex=sex</span><br><span class="line">        this.name=name</span><br><span class="line">        this.age=age</span><br><span class="line">    &#125;</span><br><span class="line">    public sayHello()&#123;</span><br><span class="line">        console.log(&apos;hello&apos;)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    protected sayBye()&#123;</span><br><span class="line">        console.log(&apos;bye&apos;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var p:people = new people(&apos;女&apos;,&apos;Limei&apos;,22)</span><br><span class="line"></span><br><span class="line">console.log(p.sex)</span><br><span class="line">console.log(p.name)   //报错</span><br><span class="line">console.log(p.age)    //报错</span><br><span class="line">p.sayHello()</span><br><span class="line">p.sayBye()    //报错</span><br></pre></td></tr></table></figure><p>只读属性修饰符<br>使用readonly修饰符将属性设置为只读，只读属性必须在生命时或者构造函数里被初始化（注意）。</p><p>我们声明一个man的抽象类，里边只有一个属性sex，并且是只读。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">class Man&#123;</span><br><span class="line">    public readonly sex:string = &apos;男&apos;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var man:Man = new Man()</span><br><span class="line">man.sex=&apos;女&apos;</span><br><span class="line">//报错</span><br></pre></td></tr></table></figure><h3 id="3、继承和重写"><a href="#3、继承和重写" class="headerlink" title="3、继承和重写"></a>3、继承和重写</h3><p>类的继承：允许我们创建一个类（子类），从已有的类（父类）上继承所有的属性和方法，子类可以新建父类中没有的属性和方法。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">class someone&#123;</span><br><span class="line">    public name:string</span><br><span class="line">    public age : number</span><br><span class="line">    public skill: string</span><br><span class="line">    constructor(name:string,age:number,skill:string)&#123;</span><br><span class="line">        this.name = name</span><br><span class="line">        this.age = age</span><br><span class="line">        this.skill = skill</span><br><span class="line">    &#125;</span><br><span class="line">    public interest()&#123;</span><br><span class="line">        console.log(&apos;game&apos;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">let someoneObj:someone = new someone(&apos;one&apos;,18,&apos;web&apos;)</span><br><span class="line">someObj.interest()</span><br><span class="line">//创建了一个类，并进行了实例化</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">class somebody extends someone&#123;</span><br><span class="line">    public xingxiang:string = &apos;帅气&apos;</span><br><span class="line">    public caihua()&#123;</span><br><span class="line">        console.log(&apos;才华横溢&apos;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">let shuai = new somebody(&quot;技术帅&quot;,5,&apos;口才好&apos;)</span><br><span class="line">shuai.interest()</span><br><span class="line">shuai.caihua()</span><br></pre></td></tr></table></figure><p>extends关键字就是继承的重点.<br>有一点需要我们注意，TypeScript不支持多重继承。</p><h3 id="4、接口"><a href="#4、接口" class="headerlink" title="4、接口"></a>4、接口</h3><p>在面向对象的语言中，术语interface经常被用来定义一个不包含数据和逻辑代码但是用来签名定义了行为的抽象类型。<br>定义接口的关键字是interface。我们现在就来定义一个接口，这个接口是图书馆的。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">interface library &#123;</span><br><span class="line">    local:string</span><br><span class="line">    room:string</span><br><span class="line">&#125;</span><br><span class="line">let slibrary:library =&#123; local:&apos;国图&apos;,room:&apos;新书馆、典藏馆&apos;&#125;</span><br><span class="line">console.log(slibrary)</span><br></pre></td></tr></table></figure><p>可选参数接口</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">interface library &#123;</span><br><span class="line">    local:string</span><br><span class="line">    room:string</span><br><span class="line">    borrow?:Boolean</span><br><span class="line">&#125;</span><br><span class="line">let slibrary:library =&#123; local:&apos;国图&apos;,room:&apos;新书馆、典藏馆&apos;,borrow:true&#125;</span><br><span class="line">console.log(slibrary)</span><br></pre></td></tr></table></figure><p>规范函数类型接口</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">interface  SearcBook&#123;</span><br><span class="line">    (source:string,subString:string):boolean</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">let mySearch:SearchBook</span><br><span class="line"></span><br><span class="line">mySearch = function(source:string,subString:string):boolean&#123;</span><br><span class="line">    let flag =source.search(subString)</span><br><span class="line">    return (flag != -1)</span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line">console.log(mySearch(&apos;高、大、上&apos;)) //false</span><br></pre></td></tr></table></figure><h3 id="5、命名空间"><a href="#5、命名空间" class="headerlink" title="5、命名空间"></a>5、命名空间</h3><p>在制作大型应用的时候，为了让程序更加有层次感和变量之间不互相干扰，我们可以使用命名空间来构建程序。当然命名空间就是解决这个问题的，命名空间，又称内部模块，被用于组织有些具有内在联系的特性和对象。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">namespace hello&#123;</span><br><span class="line">    export class world&#123;</span><br><span class="line">        public name:string = &apos;你好&apos;</span><br><span class="line">        talk()&#123;</span><br><span class="line">            console.log(&apos;你好世界&apos;)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">namespace good&#123;</span><br><span class="line">    export class bye&#123;</span><br><span class="line">        public name:string = &apos;拜拜&apos;</span><br><span class="line">        talk()&#123;</span><br><span class="line">            console.log(&apos;好的拜拜&apos;)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">let str1:hello.world   = new hello.world()</span><br><span class="line">let str2:good.bye  = new good.bye()</span><br><span class="line">str1.talk()</span><br></pre></td></tr></table></figure><h3 id="TypeScript项目demo"><a href="#TypeScript项目demo" class="headerlink" title="TypeScript项目demo"></a>TypeScript项目demo</h3><p>1、使用vue官方脚手架工具vue-cli来初始化项目 <code>npm install -g @vue/cli</code></p><p>2、运行<code>vue create my-app</code></p><p>3、安装vue-class-component和vue-property-decorator插件</p><p>vue-class-component：强化 Vue 组件，使用 TypeScript/装饰器 增强 Vue 组件<br>vue-property-decorator：在 vue-class-component 上增强更多的结合 Vue 特性的装饰器</p><p>vue-class-component</p><p>vue-class-component 对 Vue 组件进行了一层封装，让 Vue 组件语法在结合了 TypeScript 语法之后更加扁平化。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">    &lt;div&gt;</span><br><span class="line">        &lt;input v-model=&quot;msg&quot;&gt;</span><br><span class="line">        &lt;p&gt;msg: &#123;&#123; msg &#125;&#125;&lt;/p&gt;</span><br><span class="line">        &lt;p&gt;computed msg: &#123;&#123; computedMsg &#125;&#125;&lt;/p&gt;</span><br><span class="line">        &lt;button @click=&quot;greet&quot;&gt;Greet&lt;/button&gt;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line">&lt;script lang=&quot;ts&quot;&gt;</span><br><span class="line">    import Vue from &apos;vue&apos;</span><br><span class="line">    import Component from &apos;vue-class-component&apos;</span><br><span class="line"></span><br><span class="line">    @Component</span><br><span class="line">    export default class App extends Vue &#123;</span><br><span class="line">         // 初始化数据</span><br><span class="line">         msg = 123</span><br><span class="line">         // 声明周期钩子</span><br><span class="line">         mounted() &#123;</span><br><span class="line">            this.greet()</span><br><span class="line">         &#125;</span><br><span class="line">         // 计算属性</span><br><span class="line">         get computedMsg () &#123;</span><br><span class="line">            return &apos;computed &apos; + this.msg</span><br><span class="line">        &#125;</span><br><span class="line">        // 方法</span><br><span class="line">        greet () &#123;</span><br><span class="line">            alert(&apos;greeting: &apos; + this.msg)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure><p>上面的代码跟下面的代码作用是一样的</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">export default &#123;</span><br><span class="line">    data () &#123;</span><br><span class="line">      return &#123;</span><br><span class="line">          msg: 123</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  // 声明周期钩子</span><br><span class="line">  mounted () &#123;</span><br><span class="line">      this.greet()</span><br><span class="line">  &#125;</span><br><span class="line">   // 计算属性</span><br><span class="line">  computed: &#123;</span><br><span class="line">      computedMsg () &#123;</span><br><span class="line">          return &apos;computed &apos; + this.msg</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  // 方法</span><br><span class="line">  methods: &#123;</span><br><span class="line">      greet () &#123;</span><br><span class="line">      alert(&apos;greeting: &apos; + this.msg)</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>4、修改HelloWorld.vue</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">&lt;div class=&quot;blogpost&quot;&gt;</span><br><span class="line">&lt;h2&gt;&#123;&#123; post.title &#125;&#125;&lt;/h2&gt;</span><br><span class="line">&lt;p&gt;&#123;&#123; post.body &#125;&#125;&lt;/p&gt;</span><br><span class="line">&lt;p class=&quot;meta&quot;&gt;Written by &#123;&#123; post.author &#125;&#125; on &#123;&#123; date &#125;&#125;&lt;/p&gt;</span><br><span class="line">&lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script lang=&quot;ts&quot;&gt;</span><br><span class="line">import &#123; Component, Prop, Vue &#125; from &apos;vue-property-decorator&apos;;</span><br><span class="line"></span><br><span class="line">// 在这里对数据进行类型约束</span><br><span class="line">export interface Post &#123;</span><br><span class="line">title: string;</span><br><span class="line">body: string;</span><br><span class="line">author: string;</span><br><span class="line">datePosted: Date;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@Component</span><br><span class="line">export default class HelloWorld extends Vue &#123;</span><br><span class="line">@Prop() private post!: Post;</span><br><span class="line">get date() &#123;</span><br><span class="line">return `$&#123;this.post.datePosted.getDate()&#125;/$&#123;this.post.datePosted.getMonth()&#125;/$&#123;this.post.datePosted.getFullYear()&#125;`;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&lt;/script&gt;</span><br><span class="line"></span><br><span class="line">&lt;style scoped&gt;</span><br><span class="line">h2 &#123;</span><br><span class="line">  text-decoration: underline;</span><br><span class="line">&#125;</span><br><span class="line">p.meta &#123;</span><br><span class="line">  font-style: italic;</span><br><span class="line">&#125;</span><br><span class="line">&lt;/style&gt;</span><br></pre></td></tr></table></figure><p>5、修改Home.vue</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div class=&quot;home&quot;&gt;</span><br><span class="line">    &lt;img alt=&quot;Vue logo&quot; src=&quot;../assets/logo.png&quot;&gt;</span><br><span class="line">   &lt;HelloWorld v-for=&quot;blogPost in blogPosts&quot; :post=&quot;blogPost&quot; :key=&quot;blogPost.title&quot; /&gt;</span><br><span class="line">  &lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script lang=&quot;ts&quot;&gt;</span><br><span class="line">import &#123; Component, Vue &#125; from &apos;vue-property-decorator&apos;;</span><br><span class="line">import HelloWorld, &#123; Post &#125; from &apos;@/components/HelloWorld.vue&apos;; // @ is an alias to /src</span><br><span class="line"></span><br><span class="line">@Component(&#123;</span><br><span class="line">  components: &#123;</span><br><span class="line">    HelloWorld,</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;)</span><br><span class="line">export default class Home extends Vue &#123;</span><br><span class="line">    private blogPosts: Post[] = [</span><br><span class="line">        &#123;</span><br><span class="line">          title: &apos;nuxt笔记&apos;,</span><br><span class="line">          body: &apos;nuxt是vue官方推荐的服务端渲染框架&apos;,</span><br><span class="line">          author: &apos;colin&apos;,</span><br><span class="line">          datePosted: new Date(&apos;2019/11/4&apos;),</span><br><span class="line">        &#125;,</span><br><span class="line">        &#123;</span><br><span class="line">          title: &apos;typescript笔记&apos;,</span><br><span class="line">          body: &apos;typescript是javascript的超集&apos;,</span><br><span class="line">          author: &apos;colin&apos;,</span><br><span class="line">          datePosted: new Date(&apos;2019/11/5&apos;),</span><br><span class="line">        &#125;,</span><br><span class="line">        &#123;</span><br><span class="line">          title: &apos;Fultter笔记&apos;,</span><br><span class="line">          body: &apos;Flutter是谷歌的移动UI框架&apos;,</span><br><span class="line">          author: &apos;colin&apos;,</span><br><span class="line">          datePosted: new Date(&apos;2019/11/6&apos;),</span><br><span class="line">        &#125;,</span><br><span class="line">      ];</span><br><span class="line">&#125;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure><p>6、继续完成博客demo</p>]]></content>
      
      
      
        <tags>
            
            <tag> JS </tag>
            
            <tag> TS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>fultter</title>
      <link href="/2019/11/04/fultter/"/>
      <url>/2019/11/04/fultter/</url>
      
        <content type="html"><![CDATA[<h1 id="fultter简介"><a href="#fultter简介" class="headerlink" title="fultter简介"></a>fultter简介</h1>]]></content>
      
      
      
        <tags>
            
            <tag> UI </tag>
            
            <tag> Android </tag>
            
            <tag> IOS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>nuxt 笔记</title>
      <link href="/2019/11/04/nuxt/"/>
      <url>/2019/11/04/nuxt/</url>
      
        <content type="html"><![CDATA[<h1 id="Nuxt-简介"><a href="#Nuxt-简介" class="headerlink" title="Nuxt 简介"></a>Nuxt 简介</h1><p>Nuxt 作为 Vue 官方文档中“服务端渲染”中推荐的框架，SSR 这种方式对于首屏加载的时间优化显而易见，同时可以方便地进行 SEO。</p><h1 id="Nuxt-优势"><a href="#Nuxt-优势" class="headerlink" title="Nuxt 优势"></a>Nuxt 优势</h1><p>1、项目不用再为路由划分而烦恼，你只需要按照对应的文件夹层级（Page 下）创建.vue 文件即可(相当于内部封装了 vue-router)。<br>2、项目无需考虑数据传输问题，nuxt 会在模板输出之后异步请求数据（需要引入 axios 库），而且对 vuex 有进一步的封装。<br>3、nuxt 内置了 webpack，省去了配置 webpack 的步骤，nuxt 会根据配置打包对应的文件。</p><a id="more"></a><h1 id="Nuxt-项目目录结构"><a href="#Nuxt-项目目录结构" class="headerlink" title="Nuxt 项目目录结构"></a>Nuxt 项目目录结构</h1><p>assets —————–资源目录，用于组织未编译的静态资源（如 less 或 sass）<br>components ————-组件目录，用于组织应用的 Vue.js 组件<br>layouts —————-布局目录，用于组织应用的布局组件<br>middleware ————-中间件目录，用于存放应用的中间件<br>pages ——————页面目录，用于组织应用的路由及视图<br>plugins —————-插件目录，用于组织那些需要在 vue.js 应用实例化之前需要运行的 JavaScript 插件<br>static —————–静态文件目录，用于存放应用的静态资源文件，此类文件不会被 Nuxt.js 调用 Webpack 进行构建编译处理<br>store ——————存储目录，用于组织应用的 vuex 状态树文件<br>nuxt.config.js ———用于组织 Nuxt.js 应用的个性化配置<br>package.json ———–用于描述应用的依赖关系和对外暴露的脚本接口</p><h1 id="Nuxt-渲染流程"><a href="#Nuxt-渲染流程" class="headerlink" title="Nuxt 渲染流程"></a>Nuxt 渲染流程</h1><p>具体流程如下：<br>1、调用 nuxtServerInit 方法<br>当请求开始进入时，最先调用的是 nuxtServerInit 方法，可以通过这个方法预先将服务器的数据保存，如已登录的用户信息，另外，这个方法也可以执行异步操作，并等待数据解析后返回。<br>2、Middleware 层<br>经过第一步后，请求会进入 Middleware 层，在该层中有三布操作：<br>·读取 nuxt.config.js 中的全局 middleware 字段的配置，并调用相应的中间件方法<br>·匹配并加载与请求相对应的 layout<br>·调用 layout 和 page 的中间件方法<br>3、调用 validate 方法<br>在这一步可以对请求参数进行校验，或是对第一步中服务器下发的数据进行校验，如果校验失败，将抛出 404 页面。<br>4、调用 fetch 及 asyncData 方法<br>这两个方法都会在组件加载之前被调用，它们的职责各有不同，asyncData 用来异步的进行组件数据的初始化工作，而 fetch 方法偏重于异步获取数据后修改 vuex 中的状态。</p>]]></content>
      
      
      
        <tags>
            
            <tag> Vue </tag>
            
            <tag> JS </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
