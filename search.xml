<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>node爬虫</title>
      <link href="/2019/12/27/node%E7%88%AC%E8%99%AB/"/>
      <url>/2019/12/27/node%E7%88%AC%E8%99%AB/</url>
      
        <content type="html"><![CDATA[<h1 id="node爬虫入门"><a href="#node爬虫入门" class="headerlink" title="node爬虫入门"></a>node爬虫入门</h1><h2 id="爬虫和Robots协议"><a href="#爬虫和Robots协议" class="headerlink" title="爬虫和Robots协议"></a>爬虫和Robots协议</h2><p>爬虫</p><p>是一种自动获取网页内容的程序。是搜索引擎的重要组成部分，因此搜索引擎优化很大程度上就是针对爬虫而做出的优化。</p><p>Robots协议</p><p>robots.txt是一个文本文件，robots.txt是一个协议不是一个命令。<br>robots.txt是爬虫要查看的第一个文件，robots.txt告诉爬虫在服务器上什么文件是可以被查看的，爬虫机器人就会按照文件中的内容来确定访问范围。</p><a id="more"></a><p>爬虫和Robots协议是紧密相连的，一般而言admin/private是不能爬的，万一涉及到一些用户隐私等方面的东西，之后会被发现而走到法律途径的。<br>所以在业内大家也都是认可这个Robots协议的，不让你爬的页面就不要爬，还互联网一片安宁即可了。</p><p>爬虫到底爬的是什么？</p><p>说白了爬虫拿到的一段是html代码，所以说这个对于我们前端来说并不陌生了，只要我们把它转换成DOM树就可以了。</p><h2 id="node爬虫"><a href="#node爬虫" class="headerlink" title="node爬虫"></a>node爬虫</h2><p>爬虫关键步骤都围绕在于请求、 获取数据、处理数据，当然还有应对一些反爬虫的策略，比如伪造headers，ip代理等等。</p><h3 id="node-常用爬虫模块"><a href="#node-常用爬虫模块" class="headerlink" title="node 常用爬虫模块"></a>node 常用爬虫模块</h3><p>请求和获取数据模块</p><p>superagent</p><p>名字就叫做超级代理，是一个非常实用的http请求模块，常用于get、post等请求，对于nodejs爬虫我主要就用它来实现请求操作，还有一些表单post操作，模拟ajax请求等,z支持链式调用。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">superagent.post(url)</span><br><span class="line">    .set(headers) //设置请求头</span><br><span class="line">    .set(&apos;Cookie&apos;, cookie) // 设置cookie</span><br><span class="line">    .type(&apos;form&apos;)</span><br><span class="line">    .send(&#123;</span><br><span class="line">        //表单数据</span><br><span class="line">    &#125;)</span><br><span class="line">    .end(function(err, res) &#123;</span><br><span class="line">        //数据与错误处理</span><br><span class="line">        &#125;)</span><br></pre></td></tr></table></figure><p>superagent-charset</p><p>这个是上面那个模块的拓展,因为superagent只支持UTF-8,用了这个库可以指定编码,当你用superagent爬出乱码时可以使用它</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">superagent.get(url)</span><br><span class="line">    .set(headers) </span><br><span class="line">    .charset(&apos;gbk&apos;) //指定编码</span><br><span class="line">    .end(function(err, res) &#123;</span><br><span class="line">        if (err) &#123;</span><br><span class="line">            return console.err(err);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br></pre></td></tr></table></figure><p>处理数据模块</p><p>cheerio</p><p>这是一个非常好用的处理模块,是jQuery的子集,可以使用大量jQuery的语法来获取你爬虫请求到的数据,用正则真是太不友好~</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">superagent.get(url)</span><br><span class="line">    .set(headers)</span><br><span class="line">    .end(function(err, res) &#123;</span><br><span class="line">        if (err) &#123;</span><br><span class="line">            return console.err(err);</span><br><span class="line">        &#125;</span><br><span class="line">        $ = cheerio.load(res.text);</span><br><span class="line">        // $(&quot;.XXX&quot;)选中class</span><br><span class="line">        // $(&quot;#XXX&quot;)选中id</span><br><span class="line">        // ...</span><br><span class="line">        &#125;)</span><br></pre></td></tr></table></figure><p>fs</p><p>nodejs自带的文件系统模块,直接引入即可,提供了nodejs本地读写的能力,可以写入读取本地文件,我们爬虫如果不需要写入数据库,写入本地的话,就必须得用到它了</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">var fs = require(&apos;fs&apos;);</span><br><span class="line">// 读取文件</span><br><span class="line">fs.readFile(&apos;input.txt&apos;, function (err, data) &#123;</span><br><span class="line">  if (err) &#123;</span><br><span class="line">     return console.error(err);</span><br><span class="line">  &#125;</span><br><span class="line">  &#125;);</span><br><span class="line">// 写入文件</span><br><span class="line">fs.writeFile(&apos;input.txt&apos;, &apos;XXX&apos;,  function(err) &#123;</span><br><span class="line">   if (err) &#123;</span><br><span class="line">       return console.error(err);</span><br><span class="line">   &#125;</span><br><span class="line">   &#125;);</span><br></pre></td></tr></table></figure><p>excel相关</p><p>node-xlsx</p><p>这个模块挺简单上手的,我只试过导出excel,也可以读取,觉得挺方便</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">var xlsx = require(&apos;node-xlsx&apos;);</span><br><span class="line">var fs = require(&apos;fs&apos;);</span><br><span class="line">var data = [</span><br><span class="line">    [1, 2, 3],</span><br><span class="line">    [true, false, null, &apos;sheetjs&apos;],</span><br><span class="line">    [&apos;foo&apos;, &apos;bar&apos;, new Date(&apos;2014-02-19T14:30Z&apos;), &apos;0.3&apos;],</span><br><span class="line">    [&apos;baz&apos;, null, &apos;qux&apos;]</span><br><span class="line">    ];</span><br><span class="line">var buffer = xlsx.build([&#123;</span><br><span class="line">    name: &apos;mySheet&apos;,</span><br><span class="line">    data: data</span><br><span class="line">    &#125;]);</span><br><span class="line">fs.writeFile(&apos;test.xlsx&apos;, buffer, &#123;</span><br><span class="line">        &apos;flag&apos;: &apos;w+&apos;</span><br><span class="line">    &#125;, function(err) &#123;</span><br><span class="line">        if (err) &#123;</span><br><span class="line">            return console.error(err);</span><br><span class="line">        &#125;</span><br><span class="line">        console.log(&quot;写入成功&quot;);</span><br><span class="line">    &#125;);</span><br></pre></td></tr></table></figure><p>csv</p><p>.csv后缀文件可以以纯文本存储表格数据,然后我直接用fs写入,用,来分割列,用\n来分割行就解决问题了,这个简单快捷</p><p>异步处理模块</p><p>async</p><p>这是一个异步流程控制模块,还可以在爬虫时控制并发数目,通常来说我们爬取一堆url有规律的数据,我通常构造一个数组然后使用它来解决异步</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">// 我这里对一个有规律的url+urlArr[i]进行爬取</span><br><span class="line">for (var i = 1; i </span><br><span class="line">    urlArr.push(i);</span><br><span class="line">    &#125;</span><br><span class="line">// 这里是分6批执行,每一批并行,批之间按顺序</span><br><span class="line">async.eachLimit(urlArr, 6, function(item, callback) &#123;</span><br><span class="line">    spider(item, callback);//爬虫函数</span><br><span class="line">    // 用callback(null)代表完成</span><br><span class="line">    // 用callback(&apos;err&apos;)代表错误</span><br><span class="line">    &#125;, function(err) &#123;</span><br><span class="line">    if (err) &#123;</span><br><span class="line">        return console.log(err);</span><br><span class="line">    &#125;</span><br><span class="line">    console.log(&quot;结束&quot;);</span><br><span class="line">    &#125;);</span><br></pre></td></tr></table></figure><p>node-tesseract  这是验证码识别相关的</p><p>node-schedule  当我们的爬虫需要定时爬取的时候,它就可以发挥巨大作用啦</p><h2 id="node爬虫实例"><a href="#node爬虫实例" class="headerlink" title="node爬虫实例"></a>node爬虫实例</h2><h3 id="node爬虫爬取网页图片"><a href="#node爬虫爬取网页图片" class="headerlink" title="node爬虫爬取网页图片"></a>node爬虫爬取网页图片</h3><p>1、使用express搭建服务</p><p>下载安装express包 <code>npm install express</code><br>在demo.js引入express</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">const express = require(&apos;express&apos;);</span><br><span class="line">const app = express();</span><br><span class="line">app.get(&apos;/index&apos;, function(req, res) &#123;</span><br><span class="line">res.end(&apos;111&apos;)</span><br><span class="line">&#125;)</span><br><span class="line">var server = app.listen(8081, function() &#123;</span><br><span class="line">    var host = server.address().address</span><br><span class="line">    var port = server.address().port</span><br><span class="line">    console.log(&quot;应用实例，访问地址为 http://%s:%s&quot;, host, port)</span><br><span class="line"></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>运行node demo.js启动服务</p><p>2、请求我们要爬取的页面</p><p>下载安装请求模块</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">npm install superagent</span><br><span class="line">npm install superagent-charset</span><br><span class="line">npm install cheerio</span><br></pre></td></tr></table></figure><p>引入依赖</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">var superagent = require(&apos;superagent&apos;);</span><br><span class="line">var charset = require(&apos;superagent-charset&apos;);</span><br><span class="line">charset(superagent);</span><br><span class="line">const cheerio = require(&apos;cheerio&apos;);</span><br></pre></td></tr></table></figure><p>引入我们请求的地址，声明地址变量<code>const baseUrl = &#39;https://www.qqtn.com/&#39;</code></p><p>接下来发起请求</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br></pre></td><td class="code"><pre><span class="line">var superagent = require(&apos;superagent&apos;);</span><br><span class="line">var charset = require(&apos;superagent-charset&apos;);</span><br><span class="line">charset(superagent);</span><br><span class="line">var express = require(&apos;express&apos;);</span><br><span class="line">var baseUrl = &apos;https://www.qqtn.com/&apos;; //输入任何网址都可以</span><br><span class="line">const cheerio = require(&apos;cheerio&apos;);</span><br><span class="line">var fs = require(&apos;fs&apos;)</span><br><span class="line">var path = require(&apos;path&apos;)</span><br><span class="line"></span><br><span class="line">var app = express();</span><br><span class="line">app.use(express.static(&apos;static&apos;))</span><br><span class="line">app.get(&apos;/index&apos;, function(req, res) &#123;</span><br><span class="line">    //设置请求头</span><br><span class="line">    res.header(&quot;Access-Control-Allow-Origin&quot;, &quot;*&quot;);</span><br><span class="line">    res.header(&apos;Access-Control-Allow-Methods&apos;, &apos;PUT, GET, POST, DELETE, OPTIONS&apos;);</span><br><span class="line">    res.header(&quot;Access-Control-Allow-Headers&quot;, &quot;X-Requested-With&quot;);</span><br><span class="line">    res.header(&apos;Access-Control-Allow-Headers&apos;, &apos;Content-Type&apos;);</span><br><span class="line">    //类型</span><br><span class="line">    console.log(req.query)</span><br><span class="line">    var type = req.query.type;</span><br><span class="line">    //页码</span><br><span class="line">    var page = req.query.page;</span><br><span class="line">    type = type || &apos;weixin&apos;;</span><br><span class="line">    page = page || &apos;1&apos;;</span><br><span class="line">    var route = `tx/$&#123;type&#125;tx_$&#123;page&#125;.html`</span><br><span class="line">        //网页页面信息是gb2312，所以chaeset应该为.charset(&apos;gb2312&apos;)，一般网页则为utf-8,可以直接使用.charset(&apos;utf-8&apos;)</span><br><span class="line">        console.log(baseUrl + route)</span><br><span class="line">    superagent.get(baseUrl + route)</span><br><span class="line">        .charset(&apos;gb2312&apos;)</span><br><span class="line">        .end(function(err, sres) &#123;</span><br><span class="line">            var items = [];</span><br><span class="line">            if (err) &#123;</span><br><span class="line">                console.log(&apos;ERR: &apos; + err);</span><br><span class="line">                res.json(&#123; code: 400, msg: err, sets: items &#125;);</span><br><span class="line">                return;</span><br><span class="line">            &#125;</span><br><span class="line">            var $ = cheerio.load(sres.text);</span><br><span class="line">            $(&apos;div.g-main-bg ul.g-gxlist-imgbox li a&apos;).each(function(idx, element) &#123;</span><br><span class="line">                var $element = $(element);</span><br><span class="line">                var $subElement = $element.find(&apos;img&apos;);</span><br><span class="line">                var thumbImgSrc = $subElement.attr(&apos;src&apos;);</span><br><span class="line">                items.push(&#123;</span><br><span class="line">                    title: $(element).attr(&apos;title&apos;),</span><br><span class="line">                    href: $element.attr(&apos;href&apos;),</span><br><span class="line">                    thumbSrc: thumbImgSrc</span><br><span class="line">                &#125;);</span><br><span class="line">            &#125;);</span><br><span class="line">            fs.access(path.join(__dirname, &apos;/img.json&apos;), fs.constants.F_OK, err =&gt; &#123;</span><br><span class="line">                if (err) &#123; // 文件不存在</span><br><span class="line">                    fs.writeFile(path.join(__dirname,&apos;/img.json&apos;), JSON.stringify([</span><br><span class="line">                        &#123;</span><br><span class="line">                            route,</span><br><span class="line">                            items</span><br><span class="line">                        &#125;</span><br><span class="line">                    ]), err =&gt; &#123;</span><br><span class="line">                        if(err) &#123;</span><br><span class="line">                            console.log(err)</span><br><span class="line">                            return false</span><br><span class="line">                        &#125;</span><br><span class="line">                        console.log(&apos;保存成功&apos;)</span><br><span class="line">                    &#125;)</span><br><span class="line">                &#125; else &#123;</span><br><span class="line">                    fs.readFile(path.join(__dirname, &apos;/img.json&apos;), (err, data) =&gt; &#123;</span><br><span class="line">                        if (err) &#123;</span><br><span class="line">                            console.log(err)</span><br><span class="line">                            return false</span><br><span class="line">                        &#125;</span><br><span class="line">                        data = JSON.parse(data.toString())</span><br><span class="line">                        let exist = data.some((page, index) =&gt; &#123;</span><br><span class="line">                            return page.route == route</span><br><span class="line">                        &#125;)</span><br><span class="line">                        if (!exist) &#123;</span><br><span class="line">                            fs.writeFile(path.join(__dirname, &apos;img.json&apos;), JSON.stringify([</span><br><span class="line">                                ...data,</span><br><span class="line">                                &#123;</span><br><span class="line">                                    route,</span><br><span class="line">                                    items</span><br><span class="line">                                &#125;,</span><br><span class="line">                            ]), err =&gt; &#123;</span><br><span class="line">                                if (err) &#123;</span><br><span class="line">                                    console.log(err)</span><br><span class="line">                                    return false</span><br><span class="line">                                &#125;</span><br><span class="line">                            &#125;)</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;)</span><br><span class="line">                &#125;</span><br><span class="line">                res.json(&#123; code: 200, msg: &quot;&quot;, data: items &#125;);</span><br><span class="line">            &#125;)</span><br><span class="line">            console.log(items)</span><br><span class="line">        &#125;);</span><br><span class="line">&#125;);</span><br><span class="line">app.get(&apos;/show&apos;, (req, res) =&gt; &#123;</span><br><span class="line">    fs.readFile(path.join(__dirname, &apos;img.json&apos;), (err, data) =&gt; &#123;</span><br><span class="line">        if (err) &#123;</span><br><span class="line">            console.log(err)</span><br><span class="line">            return false</span><br><span class="line">        &#125;</span><br><span class="line">        res.json(data.toString())</span><br><span class="line">        </span><br><span class="line">    &#125;)</span><br><span class="line">&#125;)</span><br><span class="line">var server = app.listen(8081, function() &#123;</span><br><span class="line"></span><br><span class="line">    var host = server.address().address</span><br><span class="line">    var port = server.address().port</span><br><span class="line"></span><br><span class="line">    console.log(&quot;应用实例，访问地址为 http://%s:%s&quot;, host, port)</span><br><span class="line"></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>运行demo.js就会返回我们拿到的数据</p><h3 id="node爬虫爬取小说"><a href="#node爬虫爬取小说" class="headerlink" title="node爬虫爬取小说"></a>node爬虫爬取小说</h3><p>node模块</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">const cheerio = require(&quot;cheerio&quot;);         //再服务端进行 jq操作的库</span><br><span class="line">const request = require(&quot;request&quot;);         //对http进一步封装的请求库</span><br><span class="line">const fs = require(&quot;fs&quot;);                   //文件操作</span><br><span class="line">const path = require(&quot;path&quot;);</span><br></pre></td></tr></table></figure><p>实现步骤</p><p>选择小说目录页面<br>获取小说所有章节页面地址<br>使用request获取章节信息<br>使用cheerios获取章节标题及其章节内容<br>使用fs保存小说内容值txt文件内</p><p>1、获取小说所有章节页面地址</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 处理小说名称及其小说目录</span><br><span class="line"> * @param &#123;*&#125; body </span><br><span class="line"> */</span><br><span class="line">const booksQuery = function (body) &#123;</span><br><span class="line">    $ = cheerio.load(body);</span><br><span class="line">    booksName = $(&apos;.btitle&apos;).find(&apos;h1&apos;).text(); //小说名称</span><br><span class="line">    $(&apos;.chapterlist&apos;).find(&apos;a&apos;).each(function (i, e) &#123; //获取章节UrlList</span><br><span class="line">        list.push($(e).attr(&apos;href&apos;))</span><br><span class="line">    &#125;);</span><br><span class="line">    createFolder(path.join(__dirname, `/book/$&#123;booksName&#125;.txt`)); //创建文件夹</span><br><span class="line">    fs.createWriteStream(path.join(__dirname, `/book/$&#123;booksName&#125;.txt`)) //创建txt文件</span><br><span class="line">    console.log(`开始写入《$&#123;booksName&#125;》·······`)</span><br><span class="line">    getBody(); //获取章节信息</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>2、使用request获取章节信息</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 获取章节页面信息</span><br><span class="line"> * </span><br><span class="line"> */</span><br><span class="line">const getBody = function () &#123;</span><br><span class="line">    let primUrl = url + list[count];</span><br><span class="line">    // console.log(primUrl)</span><br><span class="line">    request(primUrl, function (err, res, body) &#123;</span><br><span class="line">        if (!err &amp;&amp; res.statusCode == 200) &#123;</span><br><span class="line">            toQuery(body);</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            console.log(&apos;err:&apos; + err)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>3、使用cheerios获取章节标题及其章节内容</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 处理章节页面信息</span><br><span class="line"> * @param &#123;any&#125; body </span><br><span class="line"> */</span><br><span class="line">const toQuery = function (body) &#123;</span><br><span class="line">    $ = cheerio.load(body);</span><br><span class="line">    const title = $(&apos;h1&apos;).text(); //获取章节标题</span><br><span class="line">    const content = Trim($(&apos;#content&apos;).text(), &apos;g&apos;); //获取当前章节文本内容并去除文本所有空格</span><br><span class="line">    writeFs(title, content);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>4、使用fs保存小说内容值txt文件内</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 写入txt文件</span><br><span class="line"> * @param &#123;*&#125; title </span><br><span class="line"> * @param &#123;*&#125; content </span><br><span class="line"> */</span><br><span class="line">const writeFs = function (title, content) &#123;</span><br><span class="line">    // 添加数据</span><br><span class="line">    fs.appendFile(path.join(__dirname, `/book/$&#123;booksName&#125;.txt`), title, function (err) &#123;</span><br><span class="line">        if (err) throw err;</span><br><span class="line">    &#125;);</span><br><span class="line">    fs.appendFile(path.join(__dirname, `/book/$&#123;booksName&#125;.txt`), content, function (err) &#123;</span><br><span class="line">        if (err) &#123;</span><br><span class="line">            console.log(err)</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            console.log(title + &apos;········保存成功&apos;)</span><br><span class="line">            if (count + 1 &lt; list.length) &#123; //当前页码是否超过章节数</span><br><span class="line">                count = count + 1;</span><br><span class="line">                getBody();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>demo代码</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br></pre></td><td class="code"><pre><span class="line">const cheerio = require(&quot;cheerio&quot;);</span><br><span class="line">const request = require(&quot;request&quot;);</span><br><span class="line">const fs = require(&quot;fs&quot;);</span><br><span class="line">const path = require(&quot;path&quot;);</span><br><span class="line">let count = 0; //叠加</span><br><span class="line">let url = &apos;https://www.x23us.me/html/150/150567/&apos;; //小说Url</span><br><span class="line">let list = []; //章节List</span><br><span class="line">let booksName = &apos;&apos;; //小说名称</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * 获取小说目录页</span><br><span class="line"> */</span><br><span class="line">const books = function () &#123;</span><br><span class="line">    request(url, function (err, res, body) &#123;</span><br><span class="line">        if (!err &amp;&amp; res.statusCode == 200) &#123;</span><br><span class="line">            console.log(`获取小说基本信息成功·······`)</span><br><span class="line">            booksQuery(body);</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            console.log(&apos;err:&apos; + err)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br><span class="line">/**</span><br><span class="line"> * 处理小说名称及其小说目录</span><br><span class="line"> * @param &#123;*&#125; body </span><br><span class="line"> */</span><br><span class="line">const booksQuery = function (body) &#123;</span><br><span class="line">    $ = cheerio.load(body);</span><br><span class="line">    booksName = $(&apos;.btitle&apos;).find(&apos;h1&apos;).text(); //小说名称</span><br><span class="line">    $(&apos;.chapterlist&apos;).find(&apos;a&apos;).each(function (i, e) &#123; //获取章节UrlList</span><br><span class="line">        list.push($(e).attr(&apos;href&apos;))</span><br><span class="line">    &#125;);</span><br><span class="line">    createFolder(path.join(__dirname, `/book/$&#123;booksName&#125;.txt`)); //创建文件夹</span><br><span class="line">    fs.createWriteStream(path.join(__dirname, `/book/$&#123;booksName&#125;.txt`)) //创建txt文件</span><br><span class="line">    console.log(`开始写入《$&#123;booksName&#125;》·······`)</span><br><span class="line">    getBody(); //获取章节信息</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">/**</span><br><span class="line"> * 获取章节页面信息</span><br><span class="line"> * </span><br><span class="line"> */</span><br><span class="line">const getBody = function () &#123;</span><br><span class="line">    let primUrl = url + list[count];</span><br><span class="line">    // console.log(primUrl)</span><br><span class="line">    request(primUrl, function (err, res, body) &#123;</span><br><span class="line">        if (!err &amp;&amp; res.statusCode == 200) &#123;</span><br><span class="line">            toQuery(body);</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            console.log(&apos;err:&apos; + err)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;;</span><br><span class="line">/**</span><br><span class="line"> * 处理章节页面信息</span><br><span class="line"> * @param &#123;any&#125; body </span><br><span class="line"> */</span><br><span class="line">const toQuery = function (body) &#123;</span><br><span class="line">    $ = cheerio.load(body);</span><br><span class="line">    const title = $(&apos;h1&apos;).text(); //获取章节标题</span><br><span class="line">    const content = Trim($(&apos;#content&apos;).text(), &apos;g&apos;); //获取当前章节文本内容并去除文本所有空格</span><br><span class="line">    writeFs(title, content);</span><br><span class="line">&#125;</span><br><span class="line">/**</span><br><span class="line"> * 写入txt文件</span><br><span class="line"> * @param &#123;*&#125; title </span><br><span class="line"> * @param &#123;*&#125; content </span><br><span class="line"> */</span><br><span class="line">const writeFs = function (title, content) &#123;</span><br><span class="line">    // 添加数据</span><br><span class="line">    fs.appendFile(path.join(__dirname, `/book/$&#123;booksName&#125;.txt`), title, function (err) &#123;</span><br><span class="line">        if (err) throw err;</span><br><span class="line">    &#125;);</span><br><span class="line">    fs.appendFile(path.join(__dirname, `/book/$&#123;booksName&#125;.txt`), content, function (err) &#123;</span><br><span class="line">        if (err) &#123;</span><br><span class="line">            console.log(err)</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            console.log(title + &apos;········保存成功&apos;)</span><br><span class="line">            if (count + 1 &lt; list.length) &#123; //当前页码是否超过章节数</span><br><span class="line">                count = count + 1;</span><br><span class="line">                getBody();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br><span class="line">/**</span><br><span class="line"> * 创建文件夹</span><br><span class="line"> * </span><br><span class="line"> * @param &#123;any&#125; to </span><br><span class="line"> */</span><br><span class="line">const createFolder = function (to) &#123; //文件写入</span><br><span class="line">    var sep = path.sep</span><br><span class="line">    var folders = path.dirname(to).split(sep);</span><br><span class="line">    var p = &apos;&apos;;</span><br><span class="line">    while (folders.length) &#123;</span><br><span class="line">        p += folders.shift() + sep;</span><br><span class="line">        if (!fs.existsSync(p)) &#123;</span><br><span class="line">            fs.mkdirSync(p);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * </span><br><span class="line"> * 去除所有空格</span><br><span class="line"> * @param &#123;any&#125; str </span><br><span class="line"> * @param &#123;any&#125; is_global </span><br><span class="line"> * @returns </span><br><span class="line"> */</span><br><span class="line">const Trim = function (str, is_global) &#123;</span><br><span class="line"></span><br><span class="line">    var result;</span><br><span class="line">    result = str.replace(/(^\s+)|(\s+$)/g, &quot;&quot;);</span><br><span class="line">    if (is_global.toLowerCase() == &quot;g&quot;)</span><br><span class="line">    &#123;</span><br><span class="line">        result = result.replace(/\s/g, &quot;&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    return result;</span><br><span class="line">&#125;</span><br><span class="line">books();</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>typescript 笔记</title>
      <link href="/2019/11/05/typescript/"/>
      <url>/2019/11/05/typescript/</url>
      
        <content type="html"><![CDATA[<h1 id="TypeScript-简介"><a href="#TypeScript-简介" class="headerlink" title="TypeScript 简介"></a>TypeScript 简介</h1><p>TypeScript 并不是一个完全新的语言, 它是 JavaScript 的超集，为 JavaScript 的生态增加了类型机制，并最终将代码编译为纯粹的 JavaScript 代码。</p><p>TypeScript 由 Microsoft开发和维护的一种开源编程语言。 它支持 JavaScript 的所有语法和语义，同时在 JavaScript 的基础上添加了可选的静态类型和基于类的面向对象编程。因而TypeScript更适合开发大型应用程序。</p><a id="more"></a><p>TypeScript 与JavaScript两者的特性对比，主要表现为以下几点：</p><p>1、TypeScript是一个应用程序级的JavaScript开发语言。（这也表示TypeScript比较牛逼，可以开发大型应用，或者说更适合开发大型应用）<br>2、TypeScript是JavaScript的超集，可以编译成纯JavaScript。这个和我们CSS离的Less或者Sass是很像的，我们用更好的代码编写方式来进行编写，最后还是有好生成原生的JavaScript语言。<br>3、TypeScript跨浏览器、跨操作系统、跨主机、且开源。由于最后他编译成了JavaScript所以只要能运行JS的地方，都可以运行我们写的程序，设置在node.js里。<br>TypeScript始于JavaScript，终于JavaScript。遵循JavaScript的语法和语义，所以对于我们前端从业者来说，学习前来得心应手，并没有太大的难度。<br>4、TypeScript可以重用JavaScript代码，调用流行的JavaScript库。<br>5、TypeScript提供了类、模块和接口，更易于构建组件和维护。</p><p>目前流行的框架中使用typesript有angular2和马上要发布vue3.0。</p><p>注：Node.js之父瑞安达尔（Ryan Dahl）发布了新的开源项目 deno，从官方介绍来看，你可以认为它是下一代 Node，使用 Go 语言代替 C++ 重新编写跨平台底层内核驱动，上层仍然使用 V8 引擎，最终提供一个安全的 TypeScript 运行环境。另Dahl在公开场合曾表示Node.js已经无力回天，Deno将是他的代替品。</p><h1 id="安装TypeScript开发环境"><a href="#安装TypeScript开发环境" class="headerlink" title="安装TypeScript开发环境"></a>安装TypeScript开发环境</h1><p>1、安装node.js开发环境</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">node -v</span><br><span class="line">npm -v</span><br></pre></td></tr></table></figure><p>2、安装TypeScript安装包</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">npm install typescirpt -g</span><br><span class="line">tsc --version</span><br></pre></td></tr></table></figure><p>3、编写一个HelloWorld程序</p><p>1.初始化项目:新建一个编程文件夹以后，可以用<code>npm init -y</code>来初始化项目，生成package.json文件<br>2.创建tsconfig.json文件，在终端中输入<code>tsc --init</code>,它是一个TypeScript项目的配置文件，可以通过读取它来设置TypeScript编译器的编译参数<br>3.安装@types/node,使用<code>npm install @types/node --dev-save</code>进行安装。这个主要是解决模块的声明文件问题<br>4.编写HelloWorld.ts文件，然后进行保存</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">var a:string = &quot;HelloWorld&quot;</span><br><span class="line">consloe.log(a)</span><br></pre></td></tr></table></figure><p>5.在Vscode的任务菜单下，打开运行生成任务，然后选择<code>tsc：构建-tsconfig.json</code>，这时候就会生成一个helloWorld.js文件<br>6.在终端中输入<code>node helloWorld.js</code>就可以看到结果了</p><h1 id="TypeScript-数据类型"><a href="#TypeScript-数据类型" class="headerlink" title="TypeScript 数据类型"></a>TypeScript 数据类型</h1><p>JavaScript的数据类型分为两种，原始数据类型和引用数据类型。<br>原始数据类型包括：布尔值Boolean、数值Number、字符串String、null、undefined 以及 ES6 中的新类型 Symbol。</p><p>TypeScript中的数据类型有：</p><p>Number:数值类型（可以是整数也可以是小数）<br>string : 字符串类型<br>Boolean: 布尔类型<br>enum：枚举类型<br>any : 任意类型<br>void：空类型<br>Array : 数组类型<br>Tuple : 元祖类型<br>Null<br>Undefined </p><h3 id="number-类型"><a href="#number-类型" class="headerlink" title="number 类型"></a>number 类型</h3><p>使用number来定义数值类型</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">let decLiteral: number = 6;</span><br><span class="line">let hexLiteral: number = 0xf00d;</span><br><span class="line">// ES6 中的二进制表示法</span><br><span class="line">let binaryLiteral: number = 0b1010;</span><br><span class="line">// ES6 中的八进制表示法</span><br><span class="line">let octalLiteral: number = 0o744;</span><br><span class="line">let notANumber: number = NaN;</span><br><span class="line">let infinityNumber: number = Infinity;</span><br></pre></td></tr></table></figure><h3 id="string-类型"><a href="#string-类型" class="headerlink" title="string 类型"></a>string 类型</h3><p>TypeScript中存在两种类型的字符串：基本类型字符串和引用类型字符串。<br>基本类型字符串：由单引号或者双引号括起来的一串字符串。<br>引用类型字符串：用new 实例化的 String类型。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">let tsc:string = &apos;typescript&apos;</span><br><span class="line">let tsca:String = new String(&quot;typescript.com&quot;)</span><br><span class="line">console.log(tsc)</span><br><span class="line">console.log(tsca)</span><br><span class="line"></span><br><span class="line">typescript</span><br><span class="line">[String: &apos;typescript.com&apos;]</span><br></pre></td></tr></table></figure><h3 id="enum枚举类型"><a href="#enum枚举类型" class="headerlink" title="enum枚举类型"></a>enum枚举类型</h3><p>假如变量时几个固定数据时，比较适合用枚举类型。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">enum season&#123;spring,summer,autumn,winter&#125;</span><br><span class="line">console.log(season.autumn)</span><br><span class="line">//返回了2，这是索引index，跟数组很像</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">enum season = &#123;</span><br><span class="line">  spring: &apos;春天&apos;,</span><br><span class="line">  summer: &apos;夏天&apos;,</span><br><span class="line">  autumn: &apos;秋天&apos;,</span><br><span class="line">  winter: &apos;冬天&apos;</span><br><span class="line">&#125;</span><br><span class="line">console.log(season.autumn)</span><br><span class="line">//返回秋天</span><br></pre></td></tr></table></figure><h3 id="any类型"><a href="#any类型" class="headerlink" title="any类型"></a>any类型</h3><p>任意值（Any）用来表示允许赋值为任意类型。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">let myFavoriteNumber: any = &apos;seven&apos;;</span><br><span class="line">myFavoriteNumber = 7;</span><br></pre></td></tr></table></figure><h3 id="void类型"><a href="#void类型" class="headerlink" title="void类型"></a>void类型</h3><p>空类型，一般用于没有任何返回值的函数</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">function name():void &#123;</span><br><span class="line">  console.log(&apos;my name is X&apos;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="array类型"><a href="#array类型" class="headerlink" title="array类型"></a>array类型</h3><p>初始化数组两种方法<br>1.字面量赋值法</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">let arr1:number[] = [1,2,3,4,5] //声明一个数值类型的数组</span><br><span class="line">let arr2:Array&lt;string&gt; = [&apos;a&apos;,&apos;b&apos;,&apos;c&apos;] //声明一个字符串类型的数组</span><br><span class="line">let arr3:Array&lt;boolean&gt; = [true,false,false] //声明一个布尔类型的数组</span><br></pre></td></tr></table></figure><p>2.构造函数赋值法</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">let arr1:number[] = new Array(1,2,3,4,5) //声明一个数值类型的数组</span><br><span class="line">let arr2:Array&lt;string&gt; = new Array(&apos;a&apos;,&apos;b&apos;,&apos;c&apos;) //声明一个字符串类型的数组</span><br><span class="line">let arr3:Array&lt;boolean&gt; = new Array(true,false,false) //声明一个布尔类型的数组</span><br></pre></td></tr></table></figure><h3 id="tuple元祖类型"><a href="#tuple元祖类型" class="headerlink" title="tuple元祖类型"></a>tuple元祖类型</h3><p>元祖是一种特殊的数组，元祖类型允许表示一个已知元素数量和类型的数组，各元素的类型不必相同。比如，你可以定义一对值分别为string和number类型的元祖。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">//声明一个元祖类型</span><br><span class="line">let x : [string,number]</span><br><span class="line">//正确的初始化</span><br><span class="line">x = [&apos;hello&apos;,10]</span><br><span class="line">//错误的初始化方法</span><br><span class="line">x = [10,&apos;hello&apos;]</span><br></pre></td></tr></table></figure><h1 id="TypeScript中的函数"><a href="#TypeScript中的函数" class="headerlink" title="TypeScript中的函数"></a>TypeScript中的函数</h1><p>函数基本是程序里第一等公民。</p><p>声明函数需要注意的是：<br>1、声明（定义）函数必须加 function 关键字<br>2、函数名与变量名一样，命名规则按照标识符规则<br>3、函数参数可有可无，多个参数之间用逗号隔开<br>4、每个参数参数由名字与类型组成，之间用分号隔开<br>5、函数的返回值可有可无，没有时，返回类型为 void<br>6、大括号中是函数体。</p><p>函数定义的三种方式：</p><p>1、函数声明法<br>函数声明法创建函数是最常用的函数定义法。使用function关键字和函数名去定义一个函数。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">function add(n1:number,n2:number):number &#123;</span><br><span class="line">  return n1+n2</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>2、函数表达式法<br>函数表达式法是将一个函数赋值给一个变量，这个变量名就是函数名。通过变量名就可以调用函数了。这种方式定义的函数，必须在定义之后，调用函数。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">var add = function(n1:number,n2:number):number &#123;</span><br><span class="line">  return n1+n2</span><br><span class="line">&#125;</span><br><span class="line">console.log(add(1,4))</span><br></pre></td></tr></table></figure><p>3、箭头函数<br>箭头函数是 ES6 中新增的函数定义的新方式，我们的 TypeScript 语言是完全支持 ES6 语法的。箭头函数定义的函数一般都用于回调函数中。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">var add = function(n1:number,n2:number):number =&gt;&#123;</span><br><span class="line">  return n1+n2</span><br><span class="line">&#125;</span><br><span class="line">console.log(add(1,4))</span><br></pre></td></tr></table></figure><h1 id="面向对象编程"><a href="#面向对象编程" class="headerlink" title="面向对象编程"></a>面向对象编程</h1><p>TypeScript就是一个基于类的面向对象编程语言。</p><h3 id="1、类的声明和使用"><a href="#1、类的声明和使用" class="headerlink" title="1、类的声明和使用"></a>1、类的声明和使用</h3><p>类是对象具体事务的一个抽象，对象是类的具体表现。<br>类的定义：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">class Person&#123;</span><br><span class="line">    name:string;</span><br><span class="line">    age:number;</span><br><span class="line">    constructor(name:string,age:number)&#123;</span><br><span class="line">        this.name = name</span><br><span class="line">        this.age = age </span><br><span class="line">    &#125;</span><br><span class="line">    say()&#123;</span><br><span class="line">        console.log(&apos;hello&apos;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">let p:Person = new Person(&apos;lihua&apos;,18)</span><br><span class="line">console.log(p)</span><br><span class="line">p.say()</span><br></pre></td></tr></table></figure><p>我们先用class关键字声明了一个类，并在里边声明了name和age属性。constructor为构造函数。构造函数的主要作用是给类中封装的属性进行赋值。</p><p>使用和定义类其实很简单，关键是理解类的思想。要有抽象逻辑的能力，这样才能复用和增强维护性。</p><h3 id="2、修饰符"><a href="#2、修饰符" class="headerlink" title="2、修饰符"></a>2、修饰符</h3><p>TypeScript语言和Java还有C#很像（因为我只会这两个面向对象的语言），类中属性的访问可以用访问修饰符来进行限制。访问修饰符分为：public、protected、private。</p><p>public:公有修饰符，可以在类内或者类外使用public修饰的属性或者行为，默认修饰符。<br>protected:受保护的修饰符，可以本类和子类中使用protected修饰的属性和行为。<br>private : 私有修饰符，只可以在类内使用private修饰的属性和行为。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">class people&#123;</span><br><span class="line">    public sex:string</span><br><span class="line">    protected name:string</span><br><span class="line">    private age:number</span><br><span class="line">    public constructor(sex:string,name:string,age:number)&#123;</span><br><span class="line">        this.sex=sex</span><br><span class="line">        this.name=name</span><br><span class="line">        this.age=age</span><br><span class="line">    &#125;</span><br><span class="line">    public sayHello()&#123;</span><br><span class="line">        console.log(&apos;hello&apos;)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    protected sayBye()&#123;</span><br><span class="line">        console.log(&apos;bye&apos;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var p:people = new people(&apos;女&apos;,&apos;Limei&apos;,22)</span><br><span class="line"></span><br><span class="line">console.log(p.sex)</span><br><span class="line">console.log(p.name)   //报错</span><br><span class="line">console.log(p.age)    //报错</span><br><span class="line">p.sayHello()</span><br><span class="line">p.sayBye()    //报错</span><br></pre></td></tr></table></figure><p>只读属性修饰符<br>使用readonly修饰符将属性设置为只读，只读属性必须在生命时或者构造函数里被初始化（注意）。</p><p>我们声明一个man的抽象类，里边只有一个属性sex，并且是只读。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">class Man&#123;</span><br><span class="line">    public readonly sex:string = &apos;男&apos;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var man:Man = new Man()</span><br><span class="line">man.sex=&apos;女&apos;</span><br><span class="line">//报错</span><br></pre></td></tr></table></figure><h3 id="3、继承和重写"><a href="#3、继承和重写" class="headerlink" title="3、继承和重写"></a>3、继承和重写</h3><p>类的继承：允许我们创建一个类（子类），从已有的类（父类）上继承所有的属性和方法，子类可以新建父类中没有的属性和方法。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">class someone&#123;</span><br><span class="line">    public name:string</span><br><span class="line">    public age : number</span><br><span class="line">    public skill: string</span><br><span class="line">    constructor(name:string,age:number,skill:string)&#123;</span><br><span class="line">        this.name = name</span><br><span class="line">        this.age = age</span><br><span class="line">        this.skill = skill</span><br><span class="line">    &#125;</span><br><span class="line">    public interest()&#123;</span><br><span class="line">        console.log(&apos;game&apos;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">let someoneObj:someone = new someone(&apos;one&apos;,18,&apos;web&apos;)</span><br><span class="line">someObj.interest()</span><br><span class="line">//创建了一个类，并进行了实例化</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">class somebody extends someone&#123;</span><br><span class="line">    public xingxiang:string = &apos;帅气&apos;</span><br><span class="line">    public caihua()&#123;</span><br><span class="line">        console.log(&apos;才华横溢&apos;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">let shuai = new somebody(&quot;技术帅&quot;,5,&apos;口才好&apos;)</span><br><span class="line">shuai.interest()</span><br><span class="line">shuai.caihua()</span><br></pre></td></tr></table></figure><p>extends关键字就是继承的重点.<br>有一点需要我们注意，TypeScript不支持多重继承。</p><h3 id="4、接口"><a href="#4、接口" class="headerlink" title="4、接口"></a>4、接口</h3><p>在面向对象的语言中，术语interface经常被用来定义一个不包含数据和逻辑代码但是用来签名定义了行为的抽象类型。<br>定义接口的关键字是interface。我们现在就来定义一个接口，这个接口是图书馆的。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">interface library &#123;</span><br><span class="line">    local:string</span><br><span class="line">    room:string</span><br><span class="line">&#125;</span><br><span class="line">let slibrary:library =&#123; local:&apos;国图&apos;,room:&apos;新书馆、典藏馆&apos;&#125;</span><br><span class="line">console.log(slibrary)</span><br></pre></td></tr></table></figure><p>可选参数接口</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">interface library &#123;</span><br><span class="line">    local:string</span><br><span class="line">    room:string</span><br><span class="line">    borrow?:Boolean</span><br><span class="line">&#125;</span><br><span class="line">let slibrary:library =&#123; local:&apos;国图&apos;,room:&apos;新书馆、典藏馆&apos;,borrow:true&#125;</span><br><span class="line">console.log(slibrary)</span><br></pre></td></tr></table></figure><p>规范函数类型接口</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">interface  SearcBook&#123;</span><br><span class="line">    (source:string,subString:string):boolean</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">let mySearch:SearchBook</span><br><span class="line"></span><br><span class="line">mySearch = function(source:string,subString:string):boolean&#123;</span><br><span class="line">    let flag =source.search(subString)</span><br><span class="line">    return (flag != -1)</span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line">console.log(mySearch(&apos;高、大、上&apos;)) //false</span><br></pre></td></tr></table></figure><h3 id="5、命名空间"><a href="#5、命名空间" class="headerlink" title="5、命名空间"></a>5、命名空间</h3><p>在制作大型应用的时候，为了让程序更加有层次感和变量之间不互相干扰，我们可以使用命名空间来构建程序。当然命名空间就是解决这个问题的，命名空间，又称内部模块，被用于组织有些具有内在联系的特性和对象。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">namespace hello&#123;</span><br><span class="line">    export class world&#123;</span><br><span class="line">        public name:string = &apos;你好&apos;</span><br><span class="line">        talk()&#123;</span><br><span class="line">            console.log(&apos;你好世界&apos;)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">namespace good&#123;</span><br><span class="line">    export class bye&#123;</span><br><span class="line">        public name:string = &apos;拜拜&apos;</span><br><span class="line">        talk()&#123;</span><br><span class="line">            console.log(&apos;好的拜拜&apos;)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">let str1:hello.world   = new hello.world()</span><br><span class="line">let str2:good.bye  = new good.bye()</span><br><span class="line">str1.talk()</span><br></pre></td></tr></table></figure><h3 id="TypeScript项目demo"><a href="#TypeScript项目demo" class="headerlink" title="TypeScript项目demo"></a>TypeScript项目demo</h3><p>1、使用vue官方脚手架工具vue-cli来初始化项目 <code>npm install -g @vue/cli</code></p><p>2、运行<code>vue create my-app</code></p><p>3、安装vue-class-component和vue-property-decorator插件</p><p>vue-class-component：强化 Vue 组件，使用 TypeScript/装饰器 增强 Vue 组件<br>vue-property-decorator：在 vue-class-component 上增强更多的结合 Vue 特性的装饰器</p><p>vue-class-component</p><p>vue-class-component 对 Vue 组件进行了一层封装，让 Vue 组件语法在结合了 TypeScript 语法之后更加扁平化。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">    &lt;div&gt;</span><br><span class="line">        &lt;input v-model=&quot;msg&quot;&gt;</span><br><span class="line">        &lt;p&gt;msg: &#123;&#123; msg &#125;&#125;&lt;/p&gt;</span><br><span class="line">        &lt;p&gt;computed msg: &#123;&#123; computedMsg &#125;&#125;&lt;/p&gt;</span><br><span class="line">        &lt;button @click=&quot;greet&quot;&gt;Greet&lt;/button&gt;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line">&lt;script lang=&quot;ts&quot;&gt;</span><br><span class="line">    import Vue from &apos;vue&apos;</span><br><span class="line">    import Component from &apos;vue-class-component&apos;</span><br><span class="line"></span><br><span class="line">    @Component</span><br><span class="line">    export default class App extends Vue &#123;</span><br><span class="line">         // 初始化数据</span><br><span class="line">         msg = 123</span><br><span class="line">         // 声明周期钩子</span><br><span class="line">         mounted() &#123;</span><br><span class="line">            this.greet()</span><br><span class="line">         &#125;</span><br><span class="line">         // 计算属性</span><br><span class="line">         get computedMsg () &#123;</span><br><span class="line">            return &apos;computed &apos; + this.msg</span><br><span class="line">        &#125;</span><br><span class="line">        // 方法</span><br><span class="line">        greet () &#123;</span><br><span class="line">            alert(&apos;greeting: &apos; + this.msg)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure><p>上面的代码跟下面的代码作用是一样的</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">export default &#123;</span><br><span class="line">    data () &#123;</span><br><span class="line">      return &#123;</span><br><span class="line">          msg: 123</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  // 声明周期钩子</span><br><span class="line">  mounted () &#123;</span><br><span class="line">      this.greet()</span><br><span class="line">  &#125;</span><br><span class="line">   // 计算属性</span><br><span class="line">  computed: &#123;</span><br><span class="line">      computedMsg () &#123;</span><br><span class="line">          return &apos;computed &apos; + this.msg</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  // 方法</span><br><span class="line">  methods: &#123;</span><br><span class="line">      greet () &#123;</span><br><span class="line">      alert(&apos;greeting: &apos; + this.msg)</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>4、修改HelloWorld.vue</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">&lt;div class=&quot;blogpost&quot;&gt;</span><br><span class="line">&lt;h2&gt;&#123;&#123; post.title &#125;&#125;&lt;/h2&gt;</span><br><span class="line">&lt;p&gt;&#123;&#123; post.body &#125;&#125;&lt;/p&gt;</span><br><span class="line">&lt;p class=&quot;meta&quot;&gt;Written by &#123;&#123; post.author &#125;&#125; on &#123;&#123; date &#125;&#125;&lt;/p&gt;</span><br><span class="line">&lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script lang=&quot;ts&quot;&gt;</span><br><span class="line">import &#123; Component, Prop, Vue &#125; from &apos;vue-property-decorator&apos;;</span><br><span class="line"></span><br><span class="line">// 在这里对数据进行类型约束</span><br><span class="line">export interface Post &#123;</span><br><span class="line">title: string;</span><br><span class="line">body: string;</span><br><span class="line">author: string;</span><br><span class="line">datePosted: Date;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@Component</span><br><span class="line">export default class HelloWorld extends Vue &#123;</span><br><span class="line">@Prop() private post!: Post;</span><br><span class="line">get date() &#123;</span><br><span class="line">return `$&#123;this.post.datePosted.getDate()&#125;/$&#123;this.post.datePosted.getMonth()&#125;/$&#123;this.post.datePosted.getFullYear()&#125;`;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&lt;/script&gt;</span><br><span class="line"></span><br><span class="line">&lt;style scoped&gt;</span><br><span class="line">h2 &#123;</span><br><span class="line">  text-decoration: underline;</span><br><span class="line">&#125;</span><br><span class="line">p.meta &#123;</span><br><span class="line">  font-style: italic;</span><br><span class="line">&#125;</span><br><span class="line">&lt;/style&gt;</span><br></pre></td></tr></table></figure><p>5、修改Home.vue</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div class=&quot;home&quot;&gt;</span><br><span class="line">    &lt;img alt=&quot;Vue logo&quot; src=&quot;../assets/logo.png&quot;&gt;</span><br><span class="line">   &lt;HelloWorld v-for=&quot;blogPost in blogPosts&quot; :post=&quot;blogPost&quot; :key=&quot;blogPost.title&quot; /&gt;</span><br><span class="line">  &lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script lang=&quot;ts&quot;&gt;</span><br><span class="line">import &#123; Component, Vue &#125; from &apos;vue-property-decorator&apos;;</span><br><span class="line">import HelloWorld, &#123; Post &#125; from &apos;@/components/HelloWorld.vue&apos;; // @ is an alias to /src</span><br><span class="line"></span><br><span class="line">@Component(&#123;</span><br><span class="line">  components: &#123;</span><br><span class="line">    HelloWorld,</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;)</span><br><span class="line">export default class Home extends Vue &#123;</span><br><span class="line">    private blogPosts: Post[] = [</span><br><span class="line">        &#123;</span><br><span class="line">          title: &apos;nuxt笔记&apos;,</span><br><span class="line">          body: &apos;nuxt是vue官方推荐的服务端渲染框架&apos;,</span><br><span class="line">          author: &apos;colin&apos;,</span><br><span class="line">          datePosted: new Date(&apos;2019/11/4&apos;),</span><br><span class="line">        &#125;,</span><br><span class="line">        &#123;</span><br><span class="line">          title: &apos;typescript笔记&apos;,</span><br><span class="line">          body: &apos;typescript是javascript的超集&apos;,</span><br><span class="line">          author: &apos;colin&apos;,</span><br><span class="line">          datePosted: new Date(&apos;2019/11/5&apos;),</span><br><span class="line">        &#125;,</span><br><span class="line">        &#123;</span><br><span class="line">          title: &apos;Fultter笔记&apos;,</span><br><span class="line">          body: &apos;Flutter是谷歌的移动UI框架&apos;,</span><br><span class="line">          author: &apos;colin&apos;,</span><br><span class="line">          datePosted: new Date(&apos;2019/11/6&apos;),</span><br><span class="line">        &#125;,</span><br><span class="line">      ];</span><br><span class="line">&#125;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure><p>6、继续完成博客demo</p>]]></content>
      
      
      
        <tags>
            
            <tag> JS </tag>
            
            <tag> TS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>flutter笔记</title>
      <link href="/2019/11/04/fultter/"/>
      <url>/2019/11/04/fultter/</url>
      
        <content type="html"><![CDATA[<h1 id="flutter简介"><a href="#flutter简介" class="headerlink" title="flutter简介"></a>flutter简介</h1><p>Flutter是谷歌的移动UI框架，可以快速在iOS和Android上构建高质量的原生用户界面。 Flutter可以与现有的代码一起工作。在全世界，Flutter正在被越来越多的开发者和组织使用，并且Flutter是完全免费、开源的。</p><h2 id="开始"><a href="#开始" class="headerlink" title="开始"></a>开始</h2><p>FLutter可以在Windows、Linux、Mac上进行开发，开发工具可以使用VS Code、Android Studio、IDEA等，本文推荐使用Android Studio，主要在于Android Studio提供了FLutter Inspector工具，可以实时审查元素，解决界面的显示适配问题。</p><a id="more"></a><h3 id="搭建开发环境"><a href="#搭建开发环境" class="headerlink" title="搭建开发环境"></a>搭建开发环境</h3><p>1、下载SDK。<br>2、配置PATH，如果使用Mac或者Linux系统，一定要将<code>bin</code>目录添加到系统PATH。<br>3、配置依赖源镜像，这一步很重要，并且需要将脚本放到启动shell中。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">export PUB_HOSTED_URL=https://pub.flutter-io.cn</span><br><span class="line"></span><br><span class="line">export FLUTTER_STORAGE_BASE_URL=https://storage.flutter-io.cn</span><br></pre></td></tr></table></figure><p>1.执行<code>flutter doctor</code>，这一步耗时会很长，需要耐心等耐。<br>2.安卓开发工具及插件，配置编辑器。</p><h3 id="配置编辑器"><a href="#配置编辑器" class="headerlink" title="配置编辑器"></a>配置编辑器</h3><p>主要是给编辑器安装相应的插件。</p><p>VS Code安装flutter插件，Android Studio和IDEA需要安装Flutter和Darter插件。</p><p>其中Android Studio和IDEA基本一样，跟VS Code的主要区别在于：</p><p>VS Code提供了更好的代码提示功能</p><p>IDEA提供了Flutter Inspector，可实时审查页面元素</p><p>可根据个人喜好、习惯选择使用。</p><h2 id="主要技术点"><a href="#主要技术点" class="headerlink" title="主要技术点"></a>主要技术点</h2><h3 id="Dart"><a href="#Dart" class="headerlink" title="Dart"></a>Dart</h3><p>Flutter项目的开发语言是Dart，Dart 是由 Google 开发的一种面向对象语言，可以编译成 ARM 和 x86 代码直接运行在 iOS、Android 设备上。</p><p>推荐先学习Dart语言官方教程，对Dart有初步了解之后再进行Flutter的学习和开发。</p><h3 id="界面开发"><a href="#界面开发" class="headerlink" title="界面开发"></a>界面开发</h3><p>终于可以进入Flutter本身了。</p><h3 id="Widget"><a href="#Widget" class="headerlink" title="Widget"></a>Widget</h3><p>Flutter中页面所有元素都是Widget，又分为StatelessWidget和StatefulWidget。</p><p>顾名思义，StatelessWidget 就是指无可变状态的 Widget，这类 Widget 的状态只由创建 Widget 时传入的参数决定，一旦创建，其状态、在页面上的展示效果也就不再改变。</p><p>而 StatefulWidget 内部则存在着可变状态。当通过setState改变这些状态时，Flutter 会重新渲染该 Widget。</p><h3 id="布局"><a href="#布局" class="headerlink" title="布局"></a>布局</h3><p>在实际开发中，主要使用了Row、Column、Container、Expanded、Stack等。</p><p>Row、Column提供了水平、垂直方向的布局，Stack提供了堆叠方式的布局，各种容器有不同的特性，可根据实际页面需求选择搭配不同的布局。</p><p>推荐学习 官方文档 及 国内维护的中文翻译。</p>]]></content>
      
      
      
        <tags>
            
            <tag> UI </tag>
            
            <tag> Android </tag>
            
            <tag> IOS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>nuxt 笔记</title>
      <link href="/2019/11/04/nuxt/"/>
      <url>/2019/11/04/nuxt/</url>
      
        <content type="html"><![CDATA[<h1 id="Nuxt-简介"><a href="#Nuxt-简介" class="headerlink" title="Nuxt 简介"></a>Nuxt 简介</h1><p>Nuxt 作为 Vue 官方文档中“服务端渲染”中推荐的框架，SSR 这种方式对于首屏加载的时间优化显而易见，同时可以方便地进行 SEO。</p><h1 id="Nuxt-优势"><a href="#Nuxt-优势" class="headerlink" title="Nuxt 优势"></a>Nuxt 优势</h1><p>1、项目不用再为路由划分而烦恼，你只需要按照对应的文件夹层级（Page 下）创建.vue 文件即可(相当于内部封装了 vue-router)。<br>2、项目无需考虑数据传输问题，nuxt 会在模板输出之后异步请求数据（需要引入 axios 库），而且对 vuex 有进一步的封装。<br>3、nuxt 内置了 webpack，省去了配置 webpack 的步骤，nuxt 会根据配置打包对应的文件。</p><a id="more"></a><h1 id="Nuxt-项目目录结构"><a href="#Nuxt-项目目录结构" class="headerlink" title="Nuxt 项目目录结构"></a>Nuxt 项目目录结构</h1><p>assets —————–资源目录，用于组织未编译的静态资源（如 less 或 sass）<br>components ————-组件目录，用于组织应用的 Vue.js 组件<br>layouts —————-布局目录，用于组织应用的布局组件<br>middleware ————-中间件目录，用于存放应用的中间件<br>pages ——————页面目录，用于组织应用的路由及视图<br>plugins —————-插件目录，用于组织那些需要在 vue.js 应用实例化之前需要运行的 JavaScript 插件<br>static —————–静态文件目录，用于存放应用的静态资源文件，此类文件不会被 Nuxt.js 调用 Webpack 进行构建编译处理<br>store ——————存储目录，用于组织应用的 vuex 状态树文件<br>nuxt.config.js ———用于组织 Nuxt.js 应用的个性化配置<br>package.json ———–用于描述应用的依赖关系和对外暴露的脚本接口</p><h1 id="Nuxt-渲染流程"><a href="#Nuxt-渲染流程" class="headerlink" title="Nuxt 渲染流程"></a>Nuxt 渲染流程</h1><p>具体流程如下：<br>1、调用 nuxtServerInit 方法<br>当请求开始进入时，最先调用的是 nuxtServerInit 方法，可以通过这个方法预先将服务器的数据保存，如已登录的用户信息，另外，这个方法也可以执行异步操作，并等待数据解析后返回。<br>2、Middleware 层<br>经过第一步后，请求会进入 Middleware 层，在该层中有三布操作：<br>·读取 nuxt.config.js 中的全局 middleware 字段的配置，并调用相应的中间件方法<br>·匹配并加载与请求相对应的 layout<br>·调用 layout 和 page 的中间件方法<br>3、调用 validate 方法<br>在这一步可以对请求参数进行校验，或是对第一步中服务器下发的数据进行校验，如果校验失败，将抛出 404 页面。<br>4、调用 fetch 及 asyncData 方法<br>这两个方法都会在组件加载之前被调用，它们的职责各有不同，asyncData 用来异步的进行组件数据的初始化工作，而 fetch 方法偏重于异步获取数据后修改 vuex 中的状态。</p>]]></content>
      
      
      
        <tags>
            
            <tag> Vue </tag>
            
            <tag> JS </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
